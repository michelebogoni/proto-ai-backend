<?php
/**
 * Code Executor
 *
 * Executes PHP code generated by AI in a safe manner.
 * Primary: Creates WP Code snippets (traceable, deactivatable)
 * Fallback: Direct execution with whitelist (if WP Code not available)
 *
 * @package CreatorCore
 */

namespace CreatorCore\Executor;

defined( 'ABSPATH' ) || exit;

use CreatorCore\Integrations\WPCodeIntegration;
use CreatorCore\Audit\AuditLogger;
use CreatorCore\Executor\CustomFileManager;
use CreatorCore\Backup\SnapshotManager;

/**
 * Class CodeExecutor
 *
 * Safely executes AI-generated PHP code with:
 * - Security validation (forbidden functions check)
 * - WP Code snippet creation (primary method)
 * - Direct execution fallback (with whitelist)
 * - Error capture and reporting
 * - Automatic rollback capability
 */
class CodeExecutor {

	/**
	 * Execution result statuses
	 */
	public const STATUS_SUCCESS     = 'success';
	public const STATUS_ERROR       = 'error';
	public const STATUS_BLOCKED     = 'blocked';
	public const STATUS_PENDING     = 'pending';

	/**
	 * Execution methods
	 */
	public const METHOD_WPCODE      = 'wpcode_snippet';
	public const METHOD_CUSTOM_FILE = 'custom_file';
	public const METHOD_DIRECT      = 'direct_execution';

	/**
	 * WP Code integration instance
	 *
	 * @var WPCodeIntegration
	 */
	private WPCodeIntegration $wpcode;

	/**
	 * Audit logger instance
	 *
	 * @var AuditLogger
	 */
	private AuditLogger $logger;

	/**
	 * Custom file manager instance
	 *
	 * @var CustomFileManager
	 */
	private CustomFileManager $custom_file_manager;

	/**
	 * Snapshot manager instance
	 *
	 * @var SnapshotManager
	 */
	private SnapshotManager $snapshot_manager;

	/**
	 * Forbidden functions that should never be executed
	 *
	 * @var array
	 */
	private array $forbidden_functions = [
		// System execution
		'exec',
		'shell_exec',
		'system',
		'passthru',
		'popen',
		'proc_open',
		'pcntl_exec',
		'pcntl_fork',
		// Dangerous eval
		'eval',
		'assert',
		'create_function',
		// File system dangerous
		'unlink',
		'rmdir',
		'rename',
		'copy',
		'mkdir',
		'chmod',
		'chown',
		'chgrp',
		// Include/require (could include malicious files)
		'include',
		'include_once',
		'require',
		'require_once',
		// Network
		'fsockopen',
		'pfsockopen',
		'stream_socket_client',
		// Serialization
		'unserialize',
		// Output/exit
		'exit',
		'die',
		// PHP settings
		'ini_set',
		'ini_alter',
		'putenv',
		'set_include_path',
		// Reflection (could be used to bypass restrictions)
		'ReflectionFunction',
		'ReflectionMethod',
	];

	/**
	 * Allowed WordPress functions whitelist
	 *
	 * @var array
	 */
	private array $allowed_wp_functions = [
		// Posts
		'wp_insert_post',
		'wp_update_post',
		'wp_delete_post',
		'get_post',
		'get_posts',
		'get_post_meta',
		'update_post_meta',
		'add_post_meta',
		'delete_post_meta',
		// Options
		'get_option',
		'update_option',
		'add_option',
		'delete_option',
		// Taxonomies
		'register_taxonomy',
		'get_terms',
		'wp_set_object_terms',
		'wp_get_object_terms',
		// CPT
		'register_post_type',
		'get_post_type_object',
		'get_post_types',
		// Hooks
		'add_action',
		'add_filter',
		'remove_action',
		'remove_filter',
		'do_action',
		'apply_filters',
		// Shortcodes
		'add_shortcode',
		'do_shortcode',
		// Users
		'get_current_user_id',
		'get_user_by',
		'get_userdata',
		'wp_get_current_user',
		// Transients
		'get_transient',
		'set_transient',
		'delete_transient',
		// Sanitization
		'sanitize_text_field',
		'sanitize_title',
		'sanitize_email',
		'sanitize_url',
		'wp_kses',
		'wp_kses_post',
		'esc_html',
		'esc_attr',
		'esc_url',
		// ACF
		'get_field',
		'update_field',
		'get_field_object',
		'have_rows',
		'the_row',
		'get_sub_field',
		'acf_add_local_field_group',
		// WooCommerce
		'wc_get_product',
		'wc_get_products',
		'wc_create_product',
		'wc_get_orders',
		// Utilities
		'wp_json_encode',
		'maybe_serialize',
		'maybe_unserialize',
		'wp_parse_args',
		'wp_list_pluck',
		'absint',
		'intval',
		'floatval',
	];

	/**
	 * Constructor
	 *
	 * @param WPCodeIntegration|null  $wpcode              WP Code integration instance.
	 * @param AuditLogger|null        $logger              Audit logger instance.
	 * @param CustomFileManager|null  $custom_file_manager Custom file manager instance.
	 * @param SnapshotManager|null    $snapshot_manager    Snapshot manager instance.
	 */
	public function __construct(
		?WPCodeIntegration $wpcode = null,
		?AuditLogger $logger = null,
		?CustomFileManager $custom_file_manager = null,
		?SnapshotManager $snapshot_manager = null
	) {
		$this->wpcode              = $wpcode ?? new WPCodeIntegration();
		$this->logger              = $logger ?? new AuditLogger();
		$this->custom_file_manager = $custom_file_manager ?? new CustomFileManager( $this->logger );
		$this->snapshot_manager    = $snapshot_manager ?? new SnapshotManager( $this->logger );
	}

	/**
	 * Execute code from AI response
	 *
	 * @param array $code_data Code data from AI response.
	 * @param array $context   Optional context for snapshots (chat_id, message_id, action_id).
	 * @return array Execution result.
	 */
	public function execute( array $code_data, array $context = [] ): array {
		$code        = $code_data['content'] ?? '';
		$title       = $code_data['title'] ?? 'Creator Generated Code';
		$description = $code_data['description'] ?? '';
		$language    = $code_data['language'] ?? 'php';
		$location    = $code_data['location'] ?? 'everywhere';
		$auto_execute = $code_data['auto_execute'] ?? false;

		// Validate code is not empty
		if ( empty( trim( $code ) ) ) {
			return $this->create_result( self::STATUS_ERROR, 'Empty code provided', null );
		}

		// Security check: validate code doesn't contain forbidden functions
		$security_check = $this->validate_code_security( $code );
		if ( ! $security_check['passed'] ) {
			$this->logger->warning( 'code_execution_blocked', [
				'reason'             => 'forbidden_function',
				'forbidden_detected' => $security_check['violations'],
			]);

			return $this->create_result(
				self::STATUS_BLOCKED,
				'Code contains forbidden functions: ' . implode( ', ', $security_check['violations'] ),
				null,
				[ 'violations' => $security_check['violations'] ]
			);
		}

		// Detect code type if not specified or if it's 'php' (may be CSS/JS)
		$detected_type = $this->custom_file_manager->detect_code_type( $code );
		if ( empty( $language ) || $language === 'php' ) {
			$language = $detected_type;
		}

		// Determine execution method
		if ( $this->wpcode->is_available() ) {
			return $this->execute_via_wpcode( $code, $title, $description, $language, $location, $auto_execute );
		}

		// Fallback to custom files (preferred over direct execution)
		return $this->execute_via_custom_files( $code, $title, $description, $language, $auto_execute, $context );
	}

	/**
	 * Execute code by creating a WP Code snippet
	 *
	 * @param string $code        PHP code.
	 * @param string $title       Snippet title.
	 * @param string $description Snippet description.
	 * @param string $language    Code language.
	 * @param string $location    Execution location.
	 * @param bool   $auto_execute Whether to auto-execute.
	 * @return array Execution result.
	 */
	private function execute_via_wpcode(
		string $code,
		string $title,
		string $description,
		string $language,
		string $location,
		bool $auto_execute
	): array {
		// Prepare code with Creator header
		$prepared_code = $this->prepare_code_for_wpcode( $code, $description );

		// Create snippet
		$snippet_id = $this->wpcode->create_snippet( [
			'title'       => 'Creator: ' . $title,
			'code'        => $prepared_code,
			'code_type'   => $this->map_language_to_wpcode_type( $language ),
			'location'    => $this->map_location_to_wpcode( $location ),
			'auto_insert' => true,
			'priority'    => 10,
			'status'      => $auto_execute ? 'publish' : 'draft',
		] );

		if ( ! $snippet_id ) {
			$this->logger->failure( 'code_execution_failed', [
				'method' => self::METHOD_WPCODE,
				'reason' => 'snippet_creation_failed',
			] );

			return $this->create_result(
				self::STATUS_ERROR,
				'Failed to create WP Code snippet',
				null
			);
		}

		// If auto_execute, the snippet is already active
		$execution_result = null;
		if ( $auto_execute ) {
			// Capture any output/errors from snippet execution
			$execution_result = $this->capture_snippet_execution( $snippet_id );
		}

		$this->logger->success( 'code_executed', [
			'method'      => self::METHOD_WPCODE,
			'snippet_id'  => $snippet_id,
			'auto_execute' => $auto_execute,
		] );

		return $this->create_result(
			self::STATUS_SUCCESS,
			$auto_execute
				? 'Code executed successfully via WP Code snippet'
				: 'Code saved as draft WP Code snippet. Activate to execute.',
			$snippet_id,
			[
				'method'           => self::METHOD_WPCODE,
				'snippet_id'       => $snippet_id,
				'snippet_status'   => $auto_execute ? 'active' : 'draft',
				'execution_result' => $execution_result,
				'rollback_method'  => sprintf( 'Deactivate or delete WP Code snippet ID %d', $snippet_id ),
			]
		);
	}

	/**
	 * Execute code via custom files (fallback when WP Code not available)
	 *
	 * @param string $code        Code content.
	 * @param string $title       Code title.
	 * @param string $description Code description.
	 * @param string $language    Code language/type.
	 * @param bool   $auto_execute Whether to auto-execute (for PHP only).
	 * @param array  $context     Optional context for snapshots (chat_id, message_id, action_id).
	 * @return array Execution result.
	 */
	private function execute_via_custom_files(
		string $code,
		string $title,
		string $description,
		string $language,
		bool $auto_execute,
		array $context = []
	): array {
		// Map language to custom file type
		$type = $this->map_language_to_file_type( $language );

		// Create delta snapshot before modification if context is provided
		$snapshot_id = null;
		if ( ! empty( $context['chat_id'] ) ) {
			$snapshot_id = $this->create_custom_file_snapshot( $type, $context, $title );
		}

		// Write to custom file
		$write_result = $this->custom_file_manager->write_code( $code, $type, $title, $description );

		if ( ! $write_result['success'] ) {
			$this->logger->failure( 'custom_file_write_failed', [
				'reason' => $write_result['error'] ?? 'Unknown error',
				'type'   => $type,
			] );

			// Fall back to direct execution for PHP only
			if ( $type === CustomFileManager::TYPE_PHP ) {
				$this->logger->info( 'fallback_to_direct_execution', [ 'title' => $title ] );
				return $this->execute_directly( $code, $title );
			}

			return $this->create_result(
				self::STATUS_ERROR,
				'Failed to write to custom file: ' . ( $write_result['error'] ?? 'Unknown error' ),
				null
			);
		}

		$mod_id = $write_result['modification_id'];

		// For PHP code with auto_execute, we need to execute it immediately
		$execution_result = null;
		if ( $type === CustomFileManager::TYPE_PHP && $auto_execute ) {
			// The PHP file is automatically loaded by our loader, but for immediate execution
			// we can run the code directly this once
			$execution_result = $this->execute_php_once( $code );
		}

		$this->logger->success( 'code_executed_via_custom_file', [
			'method'          => self::METHOD_CUSTOM_FILE,
			'modification_id' => $mod_id,
			'type'            => $type,
			'auto_execute'    => $auto_execute,
			'snapshot_id'     => $snapshot_id,
		] );

		$status_message = match ( $type ) {
			CustomFileManager::TYPE_PHP => $auto_execute
				? 'PHP code executed and saved to custom file. Will run on every page load.'
				: 'PHP code saved to custom file. Will run on every page load.',
			CustomFileManager::TYPE_CSS => 'CSS saved to custom file. Styles will be loaded on frontend.',
			CustomFileManager::TYPE_JS  => 'JavaScript saved to custom file. Script will be loaded on frontend.',
			default => 'Code saved to custom file.',
		};

		return $this->create_result(
			self::STATUS_SUCCESS,
			$status_message,
			$mod_id,
			[
				'method'           => self::METHOD_CUSTOM_FILE,
				'modification_id'  => $mod_id,
				'file'             => $write_result['file'],
				'type'             => $type,
				'execution_result' => $execution_result,
				'rollback_method'  => sprintf( 'Remove modification %s', $mod_id ),
				'snapshot_id'      => $snapshot_id,
			]
		);
	}

	/**
	 * Create a snapshot of custom file state before modification
	 *
	 * @param string $type    Code type.
	 * @param array  $context Snapshot context (chat_id, message_id, action_id).
	 * @param string $title   Operation title.
	 * @return int|null Snapshot ID or null if failed.
	 */
	private function create_custom_file_snapshot( string $type, array $context, string $title ): ?int {
		$chat_id    = (int) ( $context['chat_id'] ?? 0 );
		$message_id = (int) ( $context['message_id'] ?? 0 );
		$action_id  = (int) ( $context['action_id'] ?? 0 );

		if ( ! $chat_id ) {
			return null;
		}

		// Capture current file state
		$file_state     = $this->custom_file_manager->get_file_state( $type );
		$manifest_state = $this->custom_file_manager->get_manifest_state();

		// Create snapshot operations array
		$operations = [
			[
				'type'        => 'custom_file_modify',
				'target'      => $type,
				'title'       => $title,
				'before'      => [
					'file'     => $file_state,
					'manifest' => $manifest_state,
				],
				'after'       => null, // Will be filled after successful write
			],
		];

		$result = $this->snapshot_manager->create_snapshot(
			$chat_id,
			$message_id,
			$action_id,
			$operations
		);

		if ( is_int( $result ) ) {
			return $result;
		}

		// Log warning if snapshot failed but continue execution
		if ( is_wp_error( $result ) ) {
			$this->logger->warning( 'custom_file_snapshot_failed', [
				'error' => $result->get_error_message(),
			] );
		}

		return null;
	}

	/**
	 * Execute PHP code once (without saving)
	 *
	 * @param string $code PHP code.
	 * @return array Execution result.
	 */
	private function execute_php_once( string $code ): array {
		$prepared_code = $this->prepare_code_for_direct_execution( $code );

		ob_start();
		$errors = [];

		set_error_handler( function( $errno, $errstr, $errfile, $errline ) use ( &$errors ) {
			$errors[] = [
				'type'    => $errno,
				'message' => $errstr,
				'file'    => $errfile,
				'line'    => $errline,
			];
			return true;
		} );

		$success = false;
		$result  = null;

		try {
			$result = eval( $prepared_code );
			$success = true;
		} catch ( \Throwable $e ) {
			$errors[] = [
				'type'    => E_ERROR,
				'message' => $e->getMessage(),
				'file'    => $e->getFile(),
				'line'    => $e->getLine(),
			];
		}

		restore_error_handler();
		$output = ob_get_clean();

		return [
			'executed' => $success,
			'result'   => $result,
			'output'   => $output,
			'errors'   => $errors,
		];
	}

	/**
	 * Map language to custom file type
	 *
	 * @param string $language Language identifier.
	 * @return string Custom file type.
	 */
	private function map_language_to_file_type( string $language ): string {
		$map = [
			'php'        => CustomFileManager::TYPE_PHP,
			'css'        => CustomFileManager::TYPE_CSS,
			'javascript' => CustomFileManager::TYPE_JS,
			'js'         => CustomFileManager::TYPE_JS,
			'html'       => CustomFileManager::TYPE_PHP, // HTML goes in PHP for shortcode/output context
		];

		return $map[ strtolower( $language ) ] ?? CustomFileManager::TYPE_PHP;
	}

	/**
	 * Execute code directly (last resort fallback)
	 *
	 * @param string $code  PHP code.
	 * @param string $title Code title for logging.
	 * @return array Execution result.
	 */
	private function execute_directly( string $code, string $title ): array {
		// Additional validation for direct execution
		$whitelist_check = $this->validate_against_whitelist( $code );
		if ( ! $whitelist_check['passed'] ) {
			$this->logger->warning( 'direct_execution_blocked', [
				'reason'            => 'non_whitelisted_function',
				'unknown_functions' => $whitelist_check['unknown'],
			] );

			return $this->create_result(
				self::STATUS_BLOCKED,
				'Direct execution blocked: code uses non-whitelisted functions. Install WP Code for full functionality.',
				null,
				[ 'unknown_functions' => $whitelist_check['unknown'] ]
			);
		}

		// Prepare code for execution
		$prepared_code = $this->prepare_code_for_direct_execution( $code );

		// Capture output and errors
		ob_start();
		$error_handler_set = false;
		$errors            = [];

		// Set custom error handler
		set_error_handler( function( $errno, $errstr, $errfile, $errline ) use ( &$errors ) {
			$errors[] = [
				'type'    => $errno,
				'message' => $errstr,
				'file'    => $errfile,
				'line'    => $errline,
			];
			return true;
		} );
		$error_handler_set = true;

		$success = false;
		$result  = null;

		try {
			// Execute the code
			$result = eval( $prepared_code );
			$success = true;
		} catch ( \Throwable $e ) {
			$errors[] = [
				'type'    => E_ERROR,
				'message' => $e->getMessage(),
				'file'    => $e->getFile(),
				'line'    => $e->getLine(),
				'trace'   => $e->getTraceAsString(),
			];
		}

		// Restore error handler
		if ( $error_handler_set ) {
			restore_error_handler();
		}

		$output = ob_get_clean();

		if ( ! $success || ! empty( $errors ) ) {
			$this->logger->failure( 'direct_execution_error', [
				'title'  => $title,
				'errors' => $errors,
			] );

			return $this->create_result(
				self::STATUS_ERROR,
				'Code execution failed: ' . ( $errors[0]['message'] ?? 'Unknown error' ),
				null,
				[
					'method' => self::METHOD_DIRECT,
					'errors' => $errors,
					'output' => $output,
				]
			);
		}

		$this->logger->success( 'direct_execution_success', [
			'title'  => $title,
			'result' => is_scalar( $result ) ? $result : gettype( $result ),
		] );

		return $this->create_result(
			self::STATUS_SUCCESS,
			'Code executed successfully',
			$result,
			[
				'method' => self::METHOD_DIRECT,
				'output' => $output,
				'result' => $result,
			]
		);
	}

	/**
	 * Validate code security
	 *
	 * @param string $code PHP code.
	 * @return array Validation result with 'passed' and 'violations'.
	 */
	public function validate_code_security( string $code ): array {
		$violations = [];

		// Check for forbidden functions
		foreach ( $this->forbidden_functions as $func ) {
			// Match function calls: func( or func (
			$pattern = '/\b' . preg_quote( $func, '/' ) . '\s*\(/i';
			if ( preg_match( $pattern, $code ) ) {
				$violations[] = $func;
			}
		}

		// Check for preg_replace with /e modifier (deprecated but dangerous)
		if ( preg_match( '/preg_replace\s*\([^,]+\/[^\/]*e[^\/]*\//', $code ) ) {
			$violations[] = 'preg_replace with /e modifier';
		}

		// Check for backticks (shell execution)
		if ( preg_match( '/`[^`]+`/', $code ) ) {
			$violations[] = 'backtick shell execution';
		}

		// Check for dangerous SQL patterns
		if ( preg_match( '/\b(DROP|TRUNCATE|DELETE\s+FROM)\s+(TABLE|DATABASE)/i', $code ) ) {
			$violations[] = 'dangerous SQL statement';
		}

		return [
			'passed'     => empty( $violations ),
			'violations' => $violations,
		];
	}

	/**
	 * Validate code against whitelist (for direct execution)
	 *
	 * @param string $code PHP code.
	 * @return array Validation result with 'passed' and 'unknown'.
	 */
	private function validate_against_whitelist( string $code ): array {
		// Extract all function calls from code
		preg_match_all( '/\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/', $code, $matches );
		$called_functions = array_unique( $matches[1] ?? [] );

		// PHP built-in functions that are safe
		$safe_builtins = [
			'array', 'array_merge', 'array_map', 'array_filter', 'array_keys',
			'array_values', 'count', 'isset', 'empty', 'is_array', 'is_string',
			'is_numeric', 'is_null', 'in_array', 'str_replace', 'sprintf',
			'preg_match', 'preg_replace', 'trim', 'strtolower', 'strtoupper',
			'strlen', 'substr', 'strpos', 'explode', 'implode', 'json_encode',
			'json_decode', 'date', 'time', 'strtotime', 'number_format',
			'round', 'floor', 'ceil', 'min', 'max', 'sort', 'usort',
		];

		$all_allowed = array_merge( $this->allowed_wp_functions, $safe_builtins );

		$unknown = [];
		foreach ( $called_functions as $func ) {
			// Skip PHP keywords and constructs
			if ( in_array( $func, [ 'if', 'else', 'elseif', 'foreach', 'for', 'while', 'switch', 'case', 'return', 'new', 'class', 'function', 'try', 'catch', 'throw' ], true ) ) {
				continue;
			}

			// Check if function is allowed
			if ( ! in_array( $func, $all_allowed, true ) ) {
				// Check if it's a WordPress function that exists
				if ( ! function_exists( $func ) ) {
					$unknown[] = $func;
				}
			}
		}

		return [
			'passed'  => empty( $unknown ),
			'unknown' => $unknown,
		];
	}

	/**
	 * Prepare code for WP Code snippet
	 *
	 * @param string $code        Original code.
	 * @param string $description Description.
	 * @return string Prepared code.
	 */
	private function prepare_code_for_wpcode( string $code, string $description ): string {
		// Remove opening PHP tags if present
		$code = preg_replace( '/^<\?php\s*/', '', trim( $code ) );
		$code = preg_replace( '/\?>\s*$/', '', $code );

		// Add Creator header
		$header = sprintf(
			"/**\n * Creator Generated Snippet\n *\n * %s\n *\n * Generated: %s\n * User: %s\n */\n\n",
			$description ?: 'Auto-generated by Creator AI',
			current_time( 'c' ),
			wp_get_current_user()->user_login
		);

		return $header . $code;
	}

	/**
	 * Prepare code for direct execution
	 *
	 * @param string $code Original code.
	 * @return string Prepared code for eval().
	 */
	private function prepare_code_for_direct_execution( string $code ): string {
		// Remove opening/closing PHP tags
		$code = preg_replace( '/^<\?php\s*/', '', trim( $code ) );
		$code = preg_replace( '/\?>\s*$/', '', $code );

		// Ensure code doesn't start with return to avoid eval issues
		$code = trim( $code );

		return $code;
	}

	/**
	 * Capture snippet execution output/errors
	 *
	 * @param int $snippet_id Snippet ID.
	 * @return array|null Execution result or null.
	 */
	private function capture_snippet_execution( int $snippet_id ): ?array {
		// This would need to hook into WP Code's execution
		// For now, return basic confirmation
		return [
			'executed'   => true,
			'snippet_id' => $snippet_id,
			'note'       => 'Snippet activated. Check site for results.',
		];
	}

	/**
	 * Map language to WP Code type
	 *
	 * @param string $language Language identifier.
	 * @return string WP Code type.
	 */
	private function map_language_to_wpcode_type( string $language ): string {
		$map = [
			'php'        => 'php',
			'javascript' => 'js',
			'js'         => 'js',
			'css'        => 'css',
			'html'       => 'html',
		];

		return $map[ strtolower( $language ) ] ?? 'php';
	}

	/**
	 * Map location to WP Code location
	 *
	 * @param string $location Location identifier.
	 * @return string WP Code location.
	 */
	private function map_location_to_wpcode( string $location ): string {
		$map = [
			'everywhere'     => 'php_everywhere',
			'frontend'       => 'frontend_only',
			'admin'          => 'admin_only',
			'header'         => 'site_wide_header',
			'footer'         => 'site_wide_footer',
			'before_content' => 'before_content',
			'after_content'  => 'after_content',
		];

		return $map[ strtolower( $location ) ] ?? 'php_everywhere';
	}

	/**
	 * Create execution result array
	 *
	 * @param string     $status  Status code.
	 * @param string     $message Result message.
	 * @param mixed      $data    Result data.
	 * @param array|null $extra   Extra data.
	 * @return array
	 */
	private function create_result( string $status, string $message, $data = null, ?array $extra = null ): array {
		$result = [
			'success'   => $status === self::STATUS_SUCCESS,
			'status'    => $status,
			'message'   => $message,
			'data'      => $data,
			'timestamp' => current_time( 'c' ),
		];

		if ( $extra ) {
			$result = array_merge( $result, $extra );
		}

		return $result;
	}

	/**
	 * Rollback a code execution
	 *
	 * @param string|int $identifier Snippet ID or modification ID.
	 * @param string     $method     Execution method used.
	 * @return array Rollback result.
	 */
	public function rollback( $identifier, string $method = self::METHOD_WPCODE ): array {
		// Handle WP Code snippet rollback
		if ( $method === self::METHOD_WPCODE && $this->wpcode->is_available() ) {
			$snippet_id = (int) $identifier;
			$success = $this->wpcode->deactivate_snippet( $snippet_id );

			if ( $success ) {
				$this->logger->success( 'code_rollback', [
					'method'     => $method,
					'snippet_id' => $snippet_id,
				] );

				return $this->create_result(
					self::STATUS_SUCCESS,
					sprintf( 'Snippet %d deactivated successfully', $snippet_id ),
					$snippet_id
				);
			}

			return $this->create_result(
				self::STATUS_ERROR,
				'Failed to deactivate snippet',
				null
			);
		}

		// Handle custom file rollback
		if ( $method === self::METHOD_CUSTOM_FILE ) {
			$mod_id = (string) $identifier;
			$result = $this->custom_file_manager->remove_modification( $mod_id );

			if ( $result['success'] ) {
				$this->logger->success( 'code_rollback', [
					'method'          => $method,
					'modification_id' => $mod_id,
				] );

				return $this->create_result(
					self::STATUS_SUCCESS,
					sprintf( 'Modification %s removed successfully', $mod_id ),
					$mod_id
				);
			}

			return $this->create_result(
				self::STATUS_ERROR,
				$result['error'] ?? 'Failed to remove modification',
				null
			);
		}

		// Direct execution cannot be rolled back
		return $this->create_result(
			self::STATUS_ERROR,
			'Direct execution cannot be automatically rolled back',
			null
		);
	}

	/**
	 * Rollback by modification ID (convenience method)
	 *
	 * @param string $mod_id Modification ID.
	 * @return array Rollback result.
	 */
	public function rollback_modification( string $mod_id ): array {
		return $this->rollback( $mod_id, self::METHOD_CUSTOM_FILE );
	}

	/**
	 * Delete a code snippet completely
	 *
	 * @param int $snippet_id Snippet ID.
	 * @return array Deletion result.
	 */
	public function delete_snippet( int $snippet_id ): array {
		if ( ! $this->wpcode->is_available() ) {
			return $this->create_result(
				self::STATUS_ERROR,
				'WP Code not available',
				null
			);
		}

		$success = $this->wpcode->delete_snippet( $snippet_id, true );

		if ( $success ) {
			$this->logger->success( 'snippet_deleted', [ 'snippet_id' => $snippet_id ] );

			return $this->create_result(
				self::STATUS_SUCCESS,
				sprintf( 'Snippet %d deleted permanently', $snippet_id ),
				$snippet_id
			);
		}

		return $this->create_result(
			self::STATUS_ERROR,
			'Failed to delete snippet',
			null
		);
	}

	/**
	 * Get execution method availability
	 *
	 * @return array
	 */
	public function get_available_methods(): array {
		return [
			self::METHOD_WPCODE      => $this->wpcode->is_available(),
			self::METHOD_CUSTOM_FILE => $this->custom_file_manager->is_initialized() || true, // Can be initialized on demand
			self::METHOD_DIRECT      => true, // Always available but restricted (last resort)
		];
	}

	/**
	 * Get custom file manager instance
	 *
	 * @return CustomFileManager
	 */
	public function get_custom_file_manager(): CustomFileManager {
		return $this->custom_file_manager;
	}

	/**
	 * Get all modifications from custom files
	 *
	 * @return array
	 */
	public function get_custom_modifications(): array {
		return $this->custom_file_manager->get_manifest();
	}
}
